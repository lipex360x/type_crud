import AppError from '@shared/errors/AppError'
import Faker from 'faker'

import Fake{{pascalTableName}}Repository from '@modules/{{camelCase moduleName}}/repositories/fakes/Fake{{pascalTableName}}.repository'
import {{pascalCase useCaseName}}{{pascalCase actionName}}Service from './{{pascalCase useCaseName}}{{pascalCase actionName}}.service'

let fake{{camelCase moduleName}}Repository: Fake{{pascalTableName}}Repository
let {{camelCase useCaseName}}{{pascalCase actionName}}Service: {{pascalCase useCaseName}}{{pascalCase actionName}}Service

describe('{{pascalCase moduleName}} {{pascalCase useCaseName}} {{pascalCase actionName}}', () => {
  beforeEach(() => {
    fake{{camelCase moduleName}}Repository = new Fake{{pascalTableName}}Repository()
    {{camelCase useCaseName}}{{pascalCase actionName}}Service = new {{pascalCase useCaseName}}{{pascalCase actionName}}Service(fake{{camelCase moduleName}}Repository)
  })

  it('should be able to {{pascalCase actionName}} XXXXXXXXXXXXX', async () => {
    const data = {
      value: Faker.lorem.words(3)
    }

    const {{camelCase moduleName}} = await {{camelCase useCaseName}}{{pascalCase actionName}}Service.execute({ data })

    expect({{camelCase moduleName}}).toHaveProperty('XXXXXXXXXXXXX')
  })

  it('should not be able to {{pascalCase actionName}} XXXXXXXXXXXXX', async () => {
    const data = {
      value: Faker.lorem.words(3)
    }
    
    await expect(
      {{camelCase useCaseName}}{{pascalCase actionName}}Service.execute({ data })
    ).rejects.toBeInstanceOf(AppError)
  })
})
